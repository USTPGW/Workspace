// Unscented Kalman Filter File
// Created by Dan Kassen
// Hand-Converted to C from Matlab file written by previous senior design team

#include <stm32f4xx.h>
#include <misc.h>			
#include <stm32f4xx_usart.h>
#include <stm32f4xx_spi.h>
#include <stm32f4xx_tim.h>
#include <stm32f4xx_flash.h>
#include "arm_math.h" 
#include "math_helper.h" 

double V(double u, double v, double w);
double alpha(double u, double w);
double beta(double u, double v, double w);
double qbar(double u, double v, double w);

double Cx(double u, double w, double i);
double Cy(double u, double v, double w, double p, double r);
double Cz(double u, double w, double i);

double Cl(double u, double v, double w, double p, double r);
double Cm(double u, double w, double q);
double Cn(double u, double v, double w, double p, double r);

double L(double u, double v, double w, double p, double r);
double M(double u, double v, double w, double q);
double N(double u, double v, double w, double p, double r);

double magZ(double phi, double theta, double psi);

double f(double *x, double *out);
double h(double *x, double *out);

//void ukf(double fstate, double *x, double *P, double hmeas, double *z, double *Q, double *R);
void ukf(double *x, double *P, double *z, double *Q, double *R);
void sigmas(double *x, double *P, double c, double *X);
void ut1(double *X, double *Wm, double *Wc, double uL, double *Q, double *x1, double *X1, double *P1, double *X2);
void ut2(double *X1, double *Wm, double *Wc, double m, double *R, double *z1, double *Z1, double *P2, double *Z2);

//some "basic" matrix functions
void *cholesky(double *A, int n, double *B); 
void mult(double *mat1, double *mat2, int row1, int col1, int row2, int col2, double *matout);
void inverse(double *matr, int n, double *inv);

void Delay(__IO uint32_t nCount) {
   while(nCount--) {
  }
}

double gravity = 9.81;
double rho = 1026;
double mass = 3.402;
double buoyancy;
double motor = 1;
double S = .182775;
double b = 1.32;
double c = 0.08;
double Ixx = .8742;
double Iyy = .9032;
double Izz = .355;
double Ixz = .056;
double dt = 0.01;	

// Error Covariance Matrix
double Q[576] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0.000001, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
};

// Sensor Covariances
double R[100] = {
	0.00125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0.00125, 0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0.00125, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0.009*9.81, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0.009*9.81, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0.009*9.81, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0.0157, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0.0157, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 0.0157, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0.5, 
};

double i;
double di;
double h_cg;
double cbuoy;
double netbuoyancy;

double z[10] = {0.3205, -0.0105, 0.0125, -0.2940, 0.5880, 7.8728, 0.1500, -0.2500, 0.0500, 13.5254}; // sensor observation matrix
double x[24] = {.49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, }; // state matrix
double P[576] = {
0.000787938553,0.000023356308,-0.000136901964,0.000038636702,-0.000276760178,-0.000007437026,0.000000035401,0.000017127315,-0.000032170339,0.033736256324,0.015335830108,0.000000726211,-0.000229600562,0.000139003812,0.000003482572,-0.000000396141,0.000059601566,-0.002251523825,-0.000380013123,0.000143621871,-0.000000047347,-0.000010754225,-0.000012171674,-0.000000903858,
0.000023356308,0.003482079343,-0.000001988687,0.000062959079,0.000004569300,-0.001504801964,-0.000029689100,-0.000000305891,-0.005042243611,0.000042876709,-0.003269132518,-0.000000395625,0.000000047932,-0.000000234855,0.000000012265,-0.000000000394,0.000000168232,-0.000000740022,-0.000040750857,0.000000118045,0.000000069429,-0.000000006230,0.000017330643,0.000000352534,
-0.000136901964,-0.000001988687,0.000024524404,-0.000006503490,0.000046870189,0.000000420690,0.000000026194,-0.000002695274,0.000002544913,-0.005868103087,-0.002668255501,-0.000000125190,0.000039918736,-0.000024176246,-0.000000611817,0.000000072548,-0.000010362237,0.000391470917,0.000065932565,-0.000025015982,0.000000008134,0.000001869541,0.000002122829,0.000000157032,
0.000038636702,0.000062959079,-0.000006503490,0.000749387421,-0.000016250409,0.000004973053,0.000007237384,0.000000752098,-0.000054460066,0.002548673399,0.001774800589,-0.000000043318,-0.000013727448,0.000006171023,0.000000224832,0.000000029663,0.000005787753,-0.000160411419,-0.000396318090,0.000010957996,-0.000000077022,-0.000000767665,-0.000012609141,0.000000062024,
-0.000276760178,0.000004569300,0.000046870189,-0.000016250409,0.000761084435,-0.000004194053,-0.000000094324,-0.000005183992,-0.000008681770,-0.013100997536,-0.006427826840,-0.000000883495,0.000095977860,-0.000058047872,-0.000001420866,0.000000144874,-0.000024935669,0.000941453445,0.000161983593,-0.000059229028,0.000000020408,0.000004452501,0.000005298105,0.000000379806,
-0.000007437026,-0.001504801964,0.000000420690,0.000004973053,-0.000004194053,0.006958877259,0.000010256340,0.000000171763,0.002308872436,-0.000833556292,0.005463062200,0.000000298056,-0.000012343659,-0.000046527806,-0.000005250181,0.000037004241,0.000000939967,-0.000018347218,-0.000058154768,0.000001317543,-0.000000042952,-0.000000085881,-0.000010832593,-0.000000337202,
0.000000035401,-0.000029689100,0.000000026194,0.000007237384,-0.000000094324,0.000010256340,0.000210479136,0.000000021627,0.000026959671,0.000007043762,0.000028037218,0.000000004759,-0.000000057137,0.000000038053,0.000000000744,-0.000000000160,0.000000010587,-0.000000506823,0.000000623319,0.000000032455,-0.000000421315,-0.000000002444,-0.000000096365,-0.000000004810,
0.000017127315,-0.000000305891,-0.000002695274,0.000000752098,-0.000005183992,0.000000171763,0.000000021627,0.000058585388,0.000000489719,0.000727564363,0.000332475847,0.000000017912,-0.000004979733,0.000003008229,0.000000074973,-0.000000008413,0.000001287398,-0.000048642280,-0.000008152902,0.000003101551,-0.000000001060,-0.000000328851,-0.000000265436,-0.000000022472,
-0.000032170339,-0.005042243611,0.000002544913,-0.000054460066,-0.000008681770,0.002308872436,0.000026959671,0.000000489719,0.008150341439,0.000149343393,0.004871297747,0.000000593945,-0.000001115706,0.000000754841,-0.000000000454,0.000000004281,0.000000260338,-0.000011983067,0.000019397284,0.000000734267,-0.000000085984,-0.000000053240,-0.000028352475,-0.000000539037,
0.033736256324,0.000042876709,-0.005868103087,0.002548673399,-0.013100997536,-0.000833556292,0.000007043762,0.000727564363,0.000149343393,12157.165973293900,-0.139131487905,-0.008556243510,20.245117666716,-0.001730422276,0.000359517964,-0.000371000267,0.003462835493,-0.130249932536,-0.025088259860,0.008161556211,0.000005755157,-0.000116614640,-0.000836971948,0.012585339095,
0.015335830108,-0.003269132518,-0.002668255501,0.001774800589,-0.006427826840,0.005463062200,0.000028037218,0.000332475847,0.004871297747,-0.139131487905,12151.839280876800,0.002166296764,-0.016707042198,20.224396182557,0.000130888160,0.000190329950,0.001692501437,-0.063905539392,-0.017487394807,0.004163005341,-0.000004399836,-0.000436180047,-0.000585407684,-0.003180072564,
0.000000726211,-0.000000395625,-0.000000125190,-0.000000043318,-0.000000883495,0.000000298056,0.000000004759,0.000000017912,0.000000593945,-0.008556243510,0.002166296764,21.477530706207,-0.000085433604,0.000021395067,-0.000000100444,0.000000038708,0.000000080925,-0.000002983261,0.000000337169,0.000000148166,-0.000000095843,-0.000000536966,-0.000000328772,-16.545969991827,
-0.000229600562,0.000000047932,0.000039918736,-0.000013727448,0.000095977860,-0.000012343659,-0.000000057137,-0.000004979733,-0.000001115706,20.245117666716,-0.016707042198,-0.000085433604,0.200695587071,-0.000155742137,0.000000079692,-0.000003236083,-0.000025158994,0.000955249397,0.000135200663,-0.000062434327,0.000000104970,0.000009652043,0.000004153691,0.000125524993,
0.000139003812,-0.000000234855,-0.000024176246,0.000006171023,-0.000058047872,-0.000046527806,0.000000038053,0.000003008229,0.000000754841,-0.001730422276,20.224396182557,0.000021395067,-0.000155742137,0.200279828402,0.000003566813,-0.000014689665,0.000014797256,-0.000578565037,-0.000060821380,0.000037537841,-0.000000032281,-0.000004059514,-0.000001824526,-0.000031413006,
0.000003482572,0.000000012265,-0.000000611817,0.000000224832,-0.000001420866,-0.000005250181,0.000000000744,0.000000074973,-0.000000000454,0.000359517964,0.000130888160,-0.000000100444,0.000000079692,0.000003566813,0.000002845589,-0.000001642751,0.000000351832,-0.000014096640,-0.000002214208,0.000000925952,-0.000000000336,-0.000000067412,-0.000000071387,0.000000148556,
-0.000000396141,-0.000000000394,0.000000072548,0.000000029663,0.000000144874,0.000037004241,-0.000000000160,-0.000000008413,0.000000004281,-0.000371000267,0.000190329950,0.000000038708,-0.000003236083,-0.000014689665,-0.000001642751,0.000011472831,0.000000028421,0.000001537710,-0.000000290917,-0.000000085898,0.000000000041,0.000000007510,-0.000000007115,-0.000000056984,
0.000059601566,0.000000168232,-0.000010362237,0.000005787753,-0.000024935669,0.000000939967,0.000000010587,0.000001287398,0.000000260338,0.003462835493,0.001692501437,0.000000080925,-0.000025158994,0.000014797256,0.000000351832,0.000000028421,0.000008608760,-0.000243550284,-0.000056956192,0.000015494358,-0.000000007238,-0.000001169447,-0.000001873325,-0.000000102767,
-0.002251523825,-0.000000740022,0.000391470917,-0.000160411419,0.000941453445,-0.000018347218,-0.000000506823,-0.000048642280,-0.000011983067,-0.130249932536,-0.063905539392,-0.000002983261,0.000955249397,-0.000578565037,-0.000014096640,0.000001537710,-0.000243550284,0.009377168818,0.001579331074,-0.000587425650,0.000000197399,0.000044303541,0.000051345099,0.000003773407,
-0.000380013123,-0.000040750857,0.000065932565,-0.000396318090,0.000161983593,-0.000058154768,0.000000623319,-0.000008152902,0.000019397284,-0.025088259860,-0.017487394807,0.000000337169,0.000135200663,-0.000060821380,-0.000002214208,-0.000000290917,-0.000056956192,0.001579331074,0.003895611281,-0.000108432027,0.000000483628,0.000007559350,0.000124687247,-0.000000596607,
0.000143621871,0.000000118045,-0.000025015982,0.000010957996,-0.000059229028,0.000001317543,0.000000032455,0.000003101551,0.000000734267,0.008161556211,0.004163005341,0.000000148166,-0.000062434327,0.000037537841,0.000000925952,-0.000000085898,0.000015494358,-0.000587425650,-0.000108432027,0.000185427773,-0.000000013594,-0.000002815255,-0.000003517334,-0.000000179861,
-0.000000047347,0.000000069429,0.000000008134,-0.000000077022,0.000000020408,-0.000000042952,-0.000000421315,-0.000000001060,-0.000000085984,0.000005755157,-0.000004399836,-0.000000095843,0.000000104970,-0.000000032281,-0.000000000336,0.000000000041,-0.000000007238,0.000000197399,0.000000483628,-0.000000013594,0.000026342863,0.000000001836,0.000000024349,0.000000140871,
-0.000010754225,-0.000000006230,0.000001869541,-0.000000767665,0.000004452501,-0.000000085881,-0.000000002444,-0.000000328851,-0.000000053240,-0.000116614640,-0.000436180047,-0.000000536966,0.000009652043,-0.000004059514,-0.000000067412,0.000000007510,-0.000001169447,0.000044303541,0.000007559350,-0.000002815255,0.000000001836,0.000026408221,0.000000242775,0.000000786480,
-0.000012171674,0.000017330643,0.000002122829,-0.000012609141,0.000005298105,-0.000010832593,-0.000000096365,-0.000000265436,-0.000028352475,-0.000836971948,-0.000585407684,-0.000000328772,0.000004153691,-0.000001824526,-0.000000071387,-0.000000007115,-0.000001873325,0.000051345099,0.000124687247,-0.000003517334,0.000000024349,0.000000242775,0.000031419605,0.000000478754,
-0.000000903858,0.000000352534,0.000000157032,0.000000062024,0.000000379806,-0.000000337202,-0.000000004810,-0.000000022472,-0.000000539037,0.012585339095,-0.003180072564,-16.545969991827,0.000125524993,-0.000031413006,0.000000148556,-0.000000056984,-0.000000102767,0.000003773407,-0.000000596607,-0.000000179861,0.000000140871,0.000000786480,0.000000478754,24.322575887715
}; // covariance matrix

// debugging declares

int main(void) {
	
	netbuoyancy = mass*gravity + cbuoy;
	
	ukf(x, P, z, Q, R);
	
	while(1){
		}
}

double V(double u, double v, double w)
{return sqrt(u*u + v*v + w*w);}

double alpha(double u, double w)
{return w/u;}

double beta(double u, double v, double w)
{return v/V(u,v,w);}
	
double qbar(double u, double v, double w)
{return (rho*V(u,v,w)*V(u,v,w))/2;}
	
double Cx(double u, double w, double i)
{return 4.176*(alpha(u,w)+0.875*i)*alpha(u,w) - (0.010652+0.0393*(4.176*(alpha(u,w)+0.875*i))*(4.176*(alpha(u,w)+0.875*i)))*(1-(alpha(u,w)*alpha(u,w))/2);}

double Cy(double u, double v, double w, double p, double r)
{return 0.39569*beta(u,v,w) - 0.021877*p + 0.46644*r;}

double Cz(double u, double w, double i)
{return -4.176*(alpha(u,w)+0.875*i)*(1-(alpha(u,w)*alpha(u,w))) - (0.010652+0.0393*(4.176*(alpha(u,w)+0.875*i)*(4.176*(alpha(u,w)+0.875*i)))*alpha(u,w));}

double Cl(double u, double v, double w, double p, double r)
{return -0.52494*p + 0.00014753*beta(u,w,v) + 0.0013735*r + 64.7*(-di);}
	
double Cm(double u, double w, double q)
{return (-2.21 + 3.06*i + 4*(h_cg-0.25))*(alpha(u,w)+0.875*i) + 0.9*i - 18.305*q;}
	
double Cn(double u, double v, double w, double p, double r)
{return -.22218*beta(u,v,w) + 0.012151*p - 0.26078*r;}
	
double L(double u, double v, double w, double p, double r)
{return qbar(u,v,w)*S*b*Cl(u,v,w,p,r);}

double M(double u, double v, double w, double q)
{return qbar(u,v,w)*S*c*Cm(u,w,q);}

double N(double u, double v, double w, double p, double r)
{return qbar(u,v,w)*S*b*Cn(u,v,w,p,r);}

double magZ(double phi, double theta, double psi)
{
	double a;
	double mb;
	a = .31*theta*(1-(phi*phi)/2)*(1-(psi*psi)/2);
	mb = .31*phi*psi;
	if((a+mb)>=0)
		{return sqrt(a*a+mb*mb);}
	else
		{return -sqrt(a*a+mb*mb);}
}

double f(double *x, double *out) // state transition equation, updated to reflect 0 indexing, may need to update method of outputing
{
	//double f[24] = {0};
/*u-dot*/			out[0] = x[0] + dt*((qbar(x[0],x[1],x[2])*S*Cx(x[0],x[2],i)+motor)/mass - gravity*x[4] + (netbuoyancy/mass)*x[4]+x[8]*x[1] - x[7]*x[2]);
/*v-dot*/			out[1] = x[1] + dt*(qbar(x[0],x[1],x[2])*S*Cy(x[0],x[1],x[2],x[6],x[8])/mass + gravity*x[3]*(1-(x[4]*x[4])/2) - (netbuoyancy/mass)*x[3]*(1-(x[4]*x[4])/2) - x[8]*x[0] - x[2]*x[6]);
/*w-dot*/			out[2] = x[2] + dt*(qbar(x[0],x[1],x[2])*S*Cz(x[0],x[1],i)/mass + gravity*(1-(x[2]*x[2])/2)*(1-(x[4]*x[4])/2) - (netbuoyancy/mass)*(1-(x[3]*x[3])/2)*(1-(x[4]*x[4])/2) - x[7]*x[0] - x[6]*x[1]);
/*phi-dot*/		out[3] = x[3] + dt*(x[6] + (x[7]*x[3] + x[8]*(1-(x[3]*x[3])/2))*x[4]);
/*theta-dot*/	out[4] = x[4] + dt*(x[7]*(1-(x[3]*x[3])/2) + x[8]*x[3]);
/*psi-dot*/		out[5] = x[5] + dt*(x[7]*x[3] + x[8]*(1-(x[3]*x[3])/2)*(1/(1-(x[4]*x[4])/2)));
/*p-dot*/			out[6] = x[6] + dt*((Ixx*L(x[0],x[1],x[2],x[6],x[8]) + Ixz*N(x[0],x[1],x[2],x[6],x[8]) - (Ixz*(Iyy-Ixx-Izz)*x[6] + (Ixx*Ixx + Izz*(Izz-Iyy))*x[8])*x[7])/(Ixx*Izz  -Ixz*Ixz));
/*q-dot*/			out[7] = x[7] + dt*((M(x[0],x[1],x[2],x[7]) - (Ixx - Izz)*x[6]*x[8] - Ixz*(x[6]*x[6]-x[8]*x[8]))/Iyy);
/*r-dot*/			out[8] = x[8] + dt*((Ixz*L(x[0],x[1],x[2],x[6],x[8]) + Ixx*N(x[0],x[1],x[2],x[6],x[8]) - (Ixz*(Iyy-Ixx-Izz)*x[8] + (Ixz*Ixz + Ixx*(Ixx-Iyy))*x[6]*x[7]))/(Ixx*Izz - Ixz*Ixz));
/*x-dot*/			out[9] = x[9] + dt*((1-(x[4]*x[4])/2)*(1-(x[5]*x[5])/2)*x[0] + (-(1-(x[3]*x[3])/2)*x[5] + x[3]*x[4]*(1-(x[5]*x[5])/2))*x[1] + (x[3]*x[5] + (1-(x[3]*x[3])/2)*x[4]*(1-(x[5]*x[5])/2))*x[2]+x[12]);
/*y-dot*/			out[10] = x[10] + dt*((1-(x[4]*x[4])/2)*x[5]*x[0] + (-(1-(x[3]*x[3])/2)*(1-(x[5]*x[5])/2) + x[3]*x[4]*x[5])*x[1] + (x[3]*(1-(x[5]*x[5])/2) + (1-(x[3]*x[3])/2)*x[4]*x[5])*x[2] + x[13]);
/*z-dot*/			out[11] = x[11] + dt*(-x[4]*x[0] + x[3]*(1-(x[4]*x[4])/2)*x[1] + (1-(x[3]*x[3])/2)*(1-(x[4]*x[4])/2)*x[2]);
							out[12] = x[12]; out[13] = x[13]; out[14] = x[14]; out[15] = x[15]; out[16] = x[16]; out[17] = x[17]; // biases
							out[18] = x[18]; out[19] = x[19]; out[20] = x[20]; out[21] = x[21]; out[22] = x[22]; out[23] = x[23]; // biases
	//return f[24];
}
 
double h(double *x, double *out)
{ // observation update equation
	out[0] = .31*(1-(x[4]*x[4])/2)*(1-(x[5]*x[5])/2) + x[14]; // magnetometer x
	out[1] = .31*(1-(x[3]*x[3])/2)*-x[5] + x[15]; // magnetometer y
	out[2] = magZ(x[3],x[4],x[5]) + x[16]; // magnetometer z
	out[3] = -gravity*x[4] + x[17]; // accelerometer x
	out[4] = gravity*x[3]*(1-(x[4]*x[4])/2)+x[18]; // accelerometer y
	out[5] = gravity*(1-(x[3]*x[3])/2)*(1-(x[4]*x[4])/2) + x[20]; // accelerometer z
	out[6] = x[6] + x[20]; // gyro p
	out[7] = x[7] + x[21]; // gyro q
	out[8] = x[8] + x[22]; // gyro r
	out[9] = x[11]*1.47 + 14.223 + x[23]; // pressure in PSI (depth)
}	

void ukf(double *x, double *P, double *z, double *Q, double *R)
{
	int count;
	int countrow;
	int countcol;
	
	double uL = 24; // # of states
	double m = 10; // # of measurements
	double ualpha = .001; // default, tunable
	double ki=0; // default, tunable
	double ubeta=1; // default, tunable
	double lambda = -24.00;
	double uc = .000024;
	double ztemp[10]; // 10 x 1
	double x1[24]; // 24 x 1
	double X1[1176]; // 24 x 49
	double P1[576]; // 24 x 24
	double X2[1176]; // 24 x 49
	double z1[10]; // 10 x 1
	double Z1[490]; // 10 x 49
	double P2[100]; // 10 x 10
	double P2inv[100]; // 10 x 10
	double Z2[490]; // 10 x 49
	double Z2T[490]; // 49 x 10
	double P12[240]; // 24 x 10
	double P12T[240]; // 10 x 24
	double diag[2401]; // 49 x 49
	double temp[1176]; // 24 x 49
	double K[240]; // 24 x 10
	double PT[576]; // 24 x 24
	
	double Wc[49] = {(-24/.000024)-.000001, (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024)};
		
	double Wm[49] = {-24/.000024, (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024),
						(0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024), (0.5/.000024)};
		
	double X[1176];
	
	lambda = ualpha*ualpha*(uL+ki)-uL;
	uc = uL+lambda;
	uc = sqrt(uc);
	
	sigmas(x,P,uc,X);	
	
	ut1(X, Wm, Wc, uL, Q, x1, X1, P1, X2); // in: X, Wm, Wc, uL, Q ;; out: x1, X1, P1, X2
	ut1(X1, Wm, Wc, m, R, z1, Z1, P2, Z2); // in: X1, Wm, Wc, uL, R ;; out: z1, Z1, P2, Z2
	
	for(count=0;count<49;count++){
		diag[count*49 + count] = Wc[count]; // diag(Wc)
	}
	
	mult(X2,diag,24,49,49,49,temp); // X1*diag(Wc), output is 24x49
	
	for(countrow=0;countrow<10;countrow++){
		for(countcol=0;countcol<49;countcol++){
			Z2T[countcol*49+countrow] = Z2[countrow*49+countcol]; // Z2' (tranpose), 49x10
		}
	}
	
	mult(temp,Z2T,24,49,49,10,P12); // P12 = X2*diag(Wc)*Z2';
	
	inverse(P2, 10, P2inv); // obtain inverse of P2
	
	mult(P12,P2inv,24,10,10,10,K);
	
	for(count=0;count<10;count++){
		ztemp[count]=z[count]-z1[count]; // z - z1
	}
	
	mult(K,ztemp,24,10,10,1,x); // K*(z-z1)
	
	for(count=0;count<24;count++){
		x[count]=x[count]+x1[count]; // x = x1+K*(z-z1)
	}
	
	for(countrow=0;countrow<24;countrow++){
		for(countcol=0;countcol<10;countcol++){
			P12T[countcol*10+countrow] = P12[countrow*10+countcol]; // P12' (tranpose), 10x24
		}
	}
	
	mult(K,P12T,24,10,10,24,P); // K*P12'
	
	for(count=0;count<576;count++){
		P[count] = P1[count] - P[count]; // P = P1 - K*P12'
	}
	
	for(countrow=0;countrow<24;countrow++){
		for(countcol=0;countcol<24;countcol++){
			PT[countcol*24+countrow] = P[countrow*24+countcol]; // P' (tranpose), 24x24
		}
	}
	
	for(count=0;count<576;count++){
		P[count] = (PT[count] + P[count])/2; // P = (P+P')/2
	}
	
}

void ut1(double *X, double *Wm, double *Wc, double uL, double *Q, double *x1, double *X1, double *P1, double *X2)
{
	int countrow;
	int countcol;
	int count;
	double utL = 49;
	
	double fout[24] = {0}; // 24 x 1
	double X1T[1176] = {0}; // 49 x 24
	double diag[2401] = {0}; // 49 x 49
	double temp[1176] = {0}; // 24 x 49
	double temp2[576] = {0}; // 24 x 24

	f(X,fout); // updated states for X1
	
	for(countrow=0;countrow<24;countrow++){ // X1(:,l) = f(X(:,k)); 
		for(countcol=0;countcol<49;countcol++){
			X1[countrow*49 + countcol] = fout[countrow];
			}
	}
	
	for(count=0;count<24;count++){ // x1 = x1+Wm(k)*Y(:,k)
			x1[count] = x1[count] + Wm[count]*X1[countrow*49];
	}
	
	for(countrow=0;countrow<24;countrow++){ // X2 = X1-x1(:,ones(1,utL));
		for(countcol=0;countcol<49;countcol++){
			X2[countrow*49+countcol] = X1[countrow*49+countcol] - x1[countrow];
		}
	}
	
	for(count=0;count<49;count++){
		diag[count*49 + count] = Wc[count]; // diag(Wc)
	}
	
	mult(X1,diag,24,49,49,49,temp); // X1*diag(Wc), output is 24x49
	
	for(countrow=0;countrow<24;countrow++){
		for(countcol=0;countcol<49;countcol++){
			X1T[countcol*49+countrow] = X1[countrow*49+countcol]; // X1' (tranpose), 49x24
		}
	}
	
	mult(temp,X1,24,49,49,24,temp2);
	
	for(countrow=0;countrow<24;countrow++){
		for(countcol=0;countcol<24;countcol++){
			P1[countrow*24+countcol] = temp2[countrow*24+countcol] + Q[countrow*24+countcol]; //P1 = X1*diag(Wc)*X1'+Q;
		}
	}
	
}

void ut2(double *X1, double *Wm, double *Wc, double m, double *R, double *z1, double *Z1, double *P2, double *Z2)
{
	int countrow;
	int countcol;
	int count;
	double utL = 49;
	
	double hout[10] = {0}; // 10 x 1
	double Z1T[490] = {0}; // 49 x 10
	double diag[2401] = {0}; // 49 x 49
	double temp[490] = {0}; // 10 x 49
	double temp2[100] = {0}; // 10 x 10

	f(X1,hout); // updated states for X1
	
	for(countrow=0;countrow<10;countrow++){ // Z1(:,l) = h(X(:,k)); 
		for(countcol=0;countcol<49;countcol++){
			Z1[countrow*49 + countcol] = hout[countrow];
			}
	}
	
	for(count=0;count<10;count++){ // z1 = z1+Wm(k)*Z1(:,k)
			z1[count] = z1[count] + Wm[count]*Z1[countrow*49];
	}
	
	for(countrow=0;countrow<10;countrow++){ // Z2 = Z1-z1(:,ones(1,utL));
		for(countcol=0;countcol<49;countcol++){
			Z2[countrow*49+countcol] = Z1[countrow*49+countcol] - z1[countrow];
		}
	}
	
	for(count=0;count<49;count++){
		diag[count*49 + count] = Wc[count]; // diag(Wc)
	}
	
	mult(Z1,diag,10,49,49,49,temp); // Z1*diag(Wc), output is 10x49
	
	for(countrow=0;countrow<10;countrow++){
		for(countcol=0;countcol<49;countcol++){
			Z1T[countcol*49+countrow] = Z1[countrow*49+countcol]; // Z1' (tranpose), 49x10
		}
	}
	mult(temp,Z1,10,49,49,10,temp2);
	
	for(countrow=0;countrow<10;countrow++){
		for(countcol=0;countcol<10;countcol++){
			P2[countrow*10+countcol] = temp2[countrow*10+countcol] + R[countrow*10+countcol]; //P2 = Z1*diag(Wc)*Z1'+R;
		}
	}
	
}

void sigmas(double *x, double *P, double c, double *X)
{
	int count;
	int countrow;
	int countcol;
	
	double Y[576] = {0};
	
	double A[576] = {0};
	
	cholesky(P,24,A);
	
	for(count=0;count<576;count++)
	{A[count] = c*A[count];} // now A = c*chol(P)'
	
	for(countrow=0;countrow<24;countrow++){
		for(countcol=0;countcol<24;countcol++){
			Y[countrow*24+countcol] = x[countrow];
		}
	}
	
	for(count=0;count<24;count++)
	{X[count*49] = x[count];}
	
	for(countrow=0;countrow<24;countrow++){
		for(countcol=1;countcol<25;countcol++){
			X[countrow*49+countcol] = (Y[(countrow*24)+countcol-1] + A[(countrow*24)+countcol-1]);
		}
	}
	
	for(countrow=0;countrow<24;countrow++){
		for(countcol=25;countcol<49;countcol++){
			X[countrow*49+countcol] = (Y[(countrow*24)+countcol-25] + A[(countrow*24)+countcol-25]);
		}
	}
}

void *cholesky(double *A, int n, double *B)
{
	int i, j, k;
  double *L = (double*)calloc(n * n, sizeof(double));
 
    for (i = 0; i < n; i++){
        for (j = 0; j < (i+1); j++) {
            double s = 0;
            for (k = 0; k < j; k++)
                s += L[i * n + k] * L[j * n + k];
            L[i * n + j] = (i == j) ?
                           sqrt(A[i * n + i] - s) :
                           (1.0 / L[j * n + j] * (A[i * n + j] - s));
        }
			}
			
			for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++)
            B[i*n+j] = L[i * n + j];
			}
}

void mult(double *mat1, double *mat2, int row1, int col1, int row2, int col2, double *matout)
{
	int c = 0;
	int d = 0; 
	int k = 0;
	int sum = 0;
	
	double first[3][4] = {0};
	double second[4][3] = {0};

	for(c=0;c<3;c++){
		for(d=0;d<4;d++){
			first[c][d] = mat1[c*4+d];
		}
	}
	
	for(c=0;c<4;c++){
		for(d=0;d<3;d++){
			second[c][d] = mat1[c*3+d];
		}
	}
	
	for(c=0;c<row1;c++){
		for(d=0;d<col2;d++){
			for(k=0;k<row2;k++){
				sum = sum + mat1[c*row2+k]*mat2[k*col2+d];
			}
			
			matout[c*col2+d]=sum;
			sum=0;
		}
	}   
}

void inverse(double *matr, int n, double *inv)
{
	int i;
	int j;
	int k;
	double d[1] = {0};
	double test[100] = {0};
	double invmat[100] = 
	{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
};
	
	// define temp matrix as input matrix for easy manipulation
	for(i=0;i<n;i++){
		for(j=0;j<n;j++){
			test[i*n+j] = matr[i*n+j];
		}
	}
	
	//rref
	for(i=0;i<(n-1);i++){
		for(k=1;k<(n-i);k++){
			d[0] = test[(i+k)*n+i]/test[i*n+i];
			for(j=i;j<n;j++){
						test[(i+k)*n + j] = test[(i+k)*n+j] - d[0]*test[i*n+j];
			}
			for(j=0;j<n;j++){
				invmat[(i+k)*n + j] = invmat[(i+k)*n+j] - d[0]*invmat[i*n+j];
			}
		}
	}
	
	//turn to identity
	for(i=n-1;i>-1;i--){
		for(j=0;j<n;j++){
			invmat[i*n+j] = invmat[i*n+j]/test[i*n+i];
		}
			test[i*n+i] = test[i*n+i]/test[i*n+i];
		for(j=i;j>0;j--){
			d[0] = test[(j-1)*n+i];
			test[(j-1)*n+i] = test[(j-1)*n+i] - test[(j-1)*n+i]*test[i*n+i];
			for(k=0;k<n;k++){
				invmat[(j-1)*n+k] = invmat[(j-1)*n+k] - d[0]*invmat[i*n+k];
			}
		}
	}
	
	for(i=0;i<n*n;i++){
		inv[i] = invmat[i];
	}
}